### 4.2.6. 클러스터 내 암호화 `Enterprise Edition`
> 이 장에서는 서버 인스턴스 간에 클러스터 통신을 보호하는 방법에 대해 설명합니다.

#### 4.2.6.1. 소개
클러스터 통신 보안 솔루션은 표준 SSL/TLS 기술(공동으로 SSL이라고 함)을 기반으로 합니다. 사실상 암호화는 보안의 한 측면일 뿐이며, 인증 및 무결성이라는 다른 초석을 가집니다. 보안 솔루션은 인증 요구 사항과 함께 배포되는 주요 인프라를 기반으로 할 것입니다.

플랫폼에서의 SSL 지원은 [7.3장, "통합 SSL 프레임 워크"](../../security/ssl-framework.md)에 자세히 설명되어 있습니다. 이 장에서는 클러스터 보안과 관련된 구체적인 내용을 설명합니다.

SSL에서 엔드 포인트는 [Public Key Infrastructure(*PKI*)](../../security/ssl-framework.md#public-key-infrastructure)에 의해 관리되는 인증서를 사용하여 자신을 인증할 수 있습니다.

>> 보안 키 관리 인프라를 배포하는 것은 이 설명서의 범위를 벗어나며 숙련된 보안 전문가에게 위임해야 합니다. 아래에 설명된 예제 배포는 참조 목적으로만 사용되며 특정 제안은 권고로 간주되어야 합니다.

#### 4.2.6.2. 예제 배포
다음 단계에서는 예제 배포를 생성할 것이고, 각 단계는 아래에서 더 자세히 설명됩니다.
* [암호화 객체](../../security/ssl-framework.md#암호화-객체) 생성 및 설치
* SSL 정책 생성
* SSL 정책으로 Causal 클러스터링 구성
* 클러스터의 보안 작업 인증

**암호화 객체 생성 및 설치**

암호화 객체 생성은 대부분 이 설명서의 범위를 벗어납니다. 일반적으로 조직 내에 [인증 기관 (*CA*)](../../security/ssl-framework.md#인증-기관)이 있는 PKI가 있어야하며 여기에 조언을 제공할 수 있어야 합니다. PKI와 관련된 이 설명서의 정보는 주로 설명을 위한 것임을 참고하십시오.

인증서와 개인 키를 얻으면 각 서버에 설치할 수 있습니다. 각 서버는 CA가 서명한 자체 인증서와 해당 개인 키를 갖습니다. CA의 인증서는 `trusted` 디렉터리에 설치되므로 CA가 서명한 어떤 인증서든 신뢰할 수 있습니다. 즉, 이것은 이제 서버가 다른 서버와 신뢰를 구축할 수 있다는 것을 의미합니다.

이 예제에서는 한 채널의 양쪽 끝을 모두 인증해야만 한다는 것을 의미하는 상호 인증 설정을 배포합니다. 상호 인증을 사용하려면 SSL 정책에 `client_auth`가 `REQUIRE`(기본 값)로 설정되어야 합니다. 서버는 기본적으로 자신을 인증하도록 요구되므로 해당하는 서버 설정이 없습니다.

Neo4j는 자체 서명 인증서를 생성할 수 있지만 이를 사용하는 배포는 일반적으로 특별한 경우로 간주되어야 합니다. 그것은 경우에 따라 타당할 수 있으며, 인스턴스 간에 자체 생성 인증서를 공유하여 상호 인증된 설정을 생성할 수도 있습니다.

특정 서버에 대한 인증서가 손상된 경우, `revoked` 디렉터리에 [인증서 해지 목록(*CRL*)](../../security/ssl-framework.md#인증서-해지-목록)을 설치하여 해지할 수 있습니다. 또한 새 CA를 사용하여 다시 배포할 수도 있습니다. 만일의 사태를 위해, 필요한 경우 클러스터 전체에서 대체될 수 있는 별도의 중간 CA가 명확하게 있는 것이 좋습니다. 이 방법은 해지를 처리하고 전파를 보장하는 것보다 훨씬 쉬울 것입니다.

**예제 4.5. 암호화 객체 생성 및 설치**

-----------------------------------------------------
이 예제에서는 SSL 정책 `cluster`의 이름을 지정하기 위한 계획을 가정하고, 개인 키와 인증서 파일은 각각 cluster01.key 및 cluster01.crt로 명명된다는 것을 가정합니다. 우리는 이 서버에 대한 기본 구성을 사용하여 적절한 디렉터리 구조를 생성하고 인증서를 설치하려고 합니다:
```
$neo4j-home> mkdir certificates/cluster
$neo4j-home> mkdir certificates/cluster/trusted
$neo4j-home> mkdir certificates/cluster/revoked

$neo4j-home> cp $some-dir/cluster01.key certificates/cluster
$neo4j-home> cp $some-dir/cluster01.crt certificates/cluster
```
----------------------------------------------------

**SSL 정책 생성**

SSL 정책은 설치된 암호화 객체를 사용하며 추가로 매개 변수를 구성할 수 있습니다. 우리는 구성에서 다음 매개 변수를 사용할 것입니다:

**표 4.1. 예제 설정**

|설정 접미사| 값 | 코멘트 |
|----------|----|--------|
|`client_auth`|`REQUIRE`|이것을 `REQUIRE`로 설정하면 서버에 대한 상호 인증을 효과적으로 수행할 수 있습니다|
|`ciphers`|`TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384`|우리는 특정한 단일의 강력한 암호를 시행하고 어떤 암호가 협상되고 선택되는지에 대한 의심을 제거할 수 있습니다. 앞서 선택된 암호는 일반적으로 바람직한 완전 전방향 보안성 (Perfect Forward Secrecy)을 제공합니다. 또한 하드웨어 가속화를 크게 지원하는 대칭 암호화를 위한 고급 암호 표준 (Advanced Encryption Standard)을 사용하므로 일반적으로 성능에 거의 영향을 미치지 않습니다.|
|`tls_versions`|`TLSv1.2`|우리는 전체 클러스터를 제어하기 때문에 하위 호환성 문제없이 최신 TLS 표준을 적용할 수 있습니다. 알려진 보안 취약성은 없으며 키 교환 등에 가장 최신 알고리즘을 사용합니다.|


다음 예제에서는 클러스터에서 사용할 SSL 정책을 생성하고 구성합니다.

**예제 4.6. SSL 정책 생성**

---------------------------------------------------------
이 예제에서는 앞의 예제에 따라 디렉터리 구조가 생성되고 인증서 파일이 설치되었다고 가정합니다. 우리는 `cluster`라는 클러스터 SSL 정책을 생성하고 싶습니다. 우리는 다음 매개 변수를 정의하여 이를 수행합니다.
````
dbms.ssl.policy.cluster.base_directory=certificates/cluster
````

정책의 이름이 `cluster`이므로 해당 설정을 `dbms.ssl.policy.cluster.*` 그룹에서 구성할 수 있습니다. *neo4j.conf* 파일에 다음 내용을 추가합니다:
````````
propertiesdbms.ssl.policy.cluster.tls_versions=TLSv1.2
dbms.ssl.policy.cluster.ciphers=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
dbms.ssl.policy.cluster.client_auth=REQUIRE
`````````
------------------------------------

정책은 동일한 설정을 가진 모든 서버에서 구성해야 합니다. 설치된 실제 암호화 객체는 동일한 개인 키 및 해당 인증서를 공유하지 않기 때문에 대부분 다를 것입니다. 그러나 신뢰할 수 있는 CA 인증서는 공유됩니다.

**SSL 정책으로 Causal 클러스터링 구성**

기본적으로 causal 클러스터는 SSL 정책을 적용하지 않으며, 이것은 통신이 암호화되지 않는다는 것을 의미합니다. `causal_clustering.ssl_policy`을 이전에 작성한 SSL 정책의 이름으로 설정하면 사용을 지시할 수 있습니다.


**예제 4.7. SSL 정책으로 Causal 클러스터링 구성**

-------------------------------------------
이 예제에서는 이전 두 예제의 작업이 수행되었다고 가정합니다. 우리는 이제 `cluster`라는 SSL 정책을 사용하도록 클러스터를 구성합니다.
``````````
causal_clustering.ssl_policy=cluster
``````````
이제 인스턴스 간에 통신되는 모든 사용자 데이터가 보호됩니다. 올바르게 설정되지 않은 인스턴스는 다른 인스턴스와 통신할 수 없음을 주의하십시오.

-------------------------------------

**클러스터의 보안 작업 인증**

모든 것이 의도된대로 보호되는지 확인하려면, 예를 들어 오픈 소스 평가 도구인 `nmap` 또는 `OpenSSL`과 같은 외부 도구를 사용하여 검증해야 합니다.


**예제 4.8. 클러스터의 보안 작업 인증**

---------------------------------
이 예제에서는 클러스터의 보안 작동을 검증하기 위해 `nmap` 도구를 사용합니다. 수행할 간단한 테스트는 다음 명령어를 사용하는 암호 열거입니다:
````````
nmap --script ssl-enum-ciphers -p <port> <hostname>
`````````````
우리의 구성에 따라 호스트 이름과 포트를 조정해야 합니다. 이는 TLS가 실제로 활성화 되어 있고 의도한 암호 집합만 사용할 수 있음을 증명할 수 있습니다. 모든 서버 및 모든 적용 포트를 테스트해야 합니다.

------------------------------

테스트 목적으로, 예를 들어 신뢰할 수 없는 인증서가 있는 Neo4j의 별도 테스트 인스턴스를 활용할 수도 있습니다. 이 테스트의 예상 결과는 테스트 서버가 사용자 데이터의 복제에 참여할 수 없다는 것입니다. 디버그 로그는 일반적으로 SSL 또는 인증서 관련 예외를 인쇄하여 문제를 나타낼 것입니다.

**Java 관련 고려 사항**

위의 예제는 Java 플랫폼에서 특별히 활성화해야 하는 강력한 암호화를 사용합니다. 예제는 다음을 참조하세요: [http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html](http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html)
